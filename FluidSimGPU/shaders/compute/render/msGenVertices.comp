#version 430 core

layout (local_size_x = 1024) in; //working in 1D

struct msVertexData {
	vec4 position;
	vec4 color;
};

struct Color {
	float value;
	float density;
	vec2 velocity;
	vec4 rgba;
};

layout(std430, binding = 5) buffer msVertexBuffer {
	msVertexData msVertices[];
};

layout(std430, binding = 4) buffer ColorBuffer {
	Color colors[];
};

layout(std140, binding = 0) uniform SimulationValues {
	int numParticles;
	int numCells;
	int xCells;
	int yCells;
	int screenWidth;
	int screenHeight;
	int apPower;
	int cNumCells;
	int cxCells;
	int cyCells;
	int finalIteration;
	float maxVelocity;
	float particleRadius;
	float boundDamping;
	float kernelRadius;
	float kr2;
	float poly6;
	float spikyGrad;
	float relaxation;
	float apDenominator;
	float apConstant;
	float deltaTime;
	float gravity;
	float cResolution;
	float cResHalf;
	float cRadius;
	float cRadius2;
};

float minval = 1.0; //important!

Color lerp(Color c1, Color c2) {
	Color c = {0, 0, vec2(0, 0), vec4(0, 0, 0, 0)};

	float scale = (minval - c2.value) / (c1.value - c2.value);
	c.density = c2.density + (c1.density - c2.density) * scale;
	c.velocity = c2.velocity + (c1.velocity - c2.velocity) * scale;
	c.rgba = c2.rgba + (c1.rgba - c2.rgba) * scale;

	return c;
}

void main() {
	uint id = gl_GlobalInvocationID.x;
	if (id >= cNumCells) return;

	//color grid coordinates
	int cy = int(floor(id / cxCells));
	int cx = int(id - cy * cxCells);

	//get colors from 4 vertices, order: bottom left, bottom right, top right, top left
	int cid = cy * cxCells + cx;
	Color vCols[4] = {colors[cid],
					colors[cid + 1],
					colors[cid + cxCells + 1],
					colors[cid + cxCells]};

	//get corner positions, same order as above
	vec2 cpos[4];
	cpos[0] = vec2(cx * cResolution, cy * cResolution);
	cpos[1] = vec2((cx + 1) * cResolution, cy * cResolution);
	cpos[2] = vec2((cx + 1) * cResolution, (cy + 1) * cResolution);
	cpos[3] = vec2(cx * cResolution, (cy + 1) * cResolution);

	//get rgb colors
	

	//get possible case out of the available 15
	int code = 0;
	if (vCols[0].value > minval) code += 1;
	if (vCols[1].value > minval) code += 2;
	if (vCols[2].value > minval) code += 4;
	if (vCols[3].value > minval) code += 8;

	//average value (color at centre of cell) for deciding ambigous cases
	float avg = (vCols[0].value + vCols[1].value + vCols[2].value + vCols[3].value) / 4.0;

	//adjust id for indexing into vertex ssbo
	cid *= 12; //by 12 because 12 possible vertices per cell

	//assume case 0, a lot of these vertices hold for other cases, faster to call clear buffer?
	for (int i = cid; i < cid + 12; i++) {
		msVertices[i] = msVertexData(vec4(0,0,0,0), vec4(0,0,0,0));
	}

	//mid bottom, mid right, mid top, mid left. Apply linear interploation as we go
	vec2 mid[4];
	mid[0] = vec2(cpos[1].x + (cpos[0].x - cpos[1].x) * ((minval - vCols[1].value) / (vCols[0].value - vCols[1].value)), cpos[1].y);
	mid[1] = vec2(cpos[2].x, cpos[2].y + (cpos[1].y - cpos[2].y) * ((minval - vCols[2].value) / (vCols[1].value - vCols[2].value)));
	mid[2] = vec2(cpos[3].x + (cpos[2].x - cpos[3].x) * ((minval - vCols[3].value) / (vCols[2].value - vCols[3].value)), cpos[3].y);
	mid[3] = vec2(cpos[0].x, cpos[0].y + (cpos[3].y - cpos[0].y) * ((minval - vCols[0].value) / (vCols[3].value - vCols[0].value)));

	//get middle colours, with their values lerped
	Color mCols[4];
	mCols[0] = lerp(vCols[0], vCols[1]);
	mCols[1] = lerp(vCols[1], vCols[2]);
	mCols[2] = lerp(vCols[2], vCols[3]);
	mCols[3] = lerp(vCols[3], vCols[0]);

	vec4 vColor = vec4(0,0.7,0.7,1);

	switch(code) {
		
		//basic single corner cases
		case 1:
			msVertices[cid] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(mid[0], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[3], 0, 1), vColor);
			break;
		case 2:
			msVertices[cid] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(mid[1], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[0], 0, 1), vColor);
			break;
		case 4:
			msVertices[cid] = msVertexData(vec4(cpos[2], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(mid[2], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[1], 0, 1), vColor);
			break;
		case 8:
			msVertices[cid] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(mid[3], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[2], 0, 1), vColor);
			break;

		//horizontal line cases
		case 3:
			msVertices[cid] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[3], 0, 1), vColor);
			
			msVertices[cid + 3] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 4] = msVertexData(vec4(mid[1], 0, 1), vColor);
			msVertices[cid + 5] = msVertexData(vec4(mid[3], 0, 1), vColor);
			break;
		case 12:
			msVertices[cid] = msVertexData(vec4(cpos[2], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[1], 0, 1), vColor);
			
			msVertices[cid + 3] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			msVertices[cid + 4] = msVertexData(vec4(mid[3], 0, 1), vColor);
			msVertices[cid + 5] = msVertexData(vec4(mid[1], 0, 1), vColor);
			break;

		//vertical line cases
		case 6:
			msVertices[cid] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(cpos[2], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[0], 0, 1), vColor);
			
			msVertices[cid + 3] = msVertexData(vec4(cpos[2], 0, 1), vColor);
			msVertices[cid + 4] = msVertexData(vec4(mid[2], 0, 1), vColor);
			msVertices[cid + 5] = msVertexData(vec4(mid[0], 0, 1), vColor);
			break;
		case 9:
			msVertices[cid] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(mid[0], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[2], 0, 1), vColor);
			
			msVertices[cid + 3] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			msVertices[cid + 4] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 5] = msVertexData(vec4(mid[2], 0, 1), vColor);
			break;

		//3 point cases
		case 7:
			msVertices[cid] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(mid[2], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[3], 0, 1), vColor);
			
			msVertices[cid + 3] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 4] = msVertexData(vec4(cpos[2], 0, 1), vColor);
			msVertices[cid + 5] = msVertexData(vec4(mid[2], 0, 1), vColor);
			
			msVertices[cid + 6] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 7] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 8] = msVertexData(vec4(cpos[2], 0, 1), vColor);
			break;
		case 11:
			msVertices[cid] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(mid[1], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[2], 0, 1), vColor);
			
			msVertices[cid + 3] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 4] = msVertexData(vec4(mid[2], 0, 1), vColor);
			msVertices[cid + 5] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			
			msVertices[cid + 6] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 7] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			msVertices[cid + 8] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			break;
		case 13:
			msVertices[cid] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(mid[0], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[1], 0, 1), vColor);
			
			msVertices[cid + 3] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 4] = msVertexData(vec4(mid[1], 0, 1), vColor);
			msVertices[cid + 5] = msVertexData(vec4(cpos[2], 0, 1), vColor);
			
			msVertices[cid + 6] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 7] = msVertexData(vec4(cpos[2], 0, 1), vColor);
			msVertices[cid + 8] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			break;
		case 14:
			msVertices[cid] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(mid[3], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(mid[0], 0, 1), vColor);
			
			msVertices[cid + 3] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			msVertices[cid + 4] = msVertexData(vec4(mid[0], 0, 1), vColor);
			msVertices[cid + 5] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			
			msVertices[cid + 6] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			msVertices[cid + 7] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 8] = msVertexData(vec4(cpos[2], 0, 1), vColor);
			break;

		//ambigous cases
		case 5:
			if (avg > minval) { //liquid is in centre of cell
				msVertices[cid] = msVertexData(vec4(cpos[0], 0, 1), vColor);
				msVertices[cid + 1] = msVertexData(vec4(mid[2], 0, 1), vColor);
				msVertices[cid + 2] = msVertexData(vec4(mid[3], 0, 1), vColor);
			
				msVertices[cid + 3] = msVertexData(vec4(cpos[0], 0, 1), vColor);
				msVertices[cid + 4] = msVertexData(vec4(cpos[2], 0, 1), vColor);
				msVertices[cid + 5] = msVertexData(vec4(mid[2], 0, 1), vColor);
			
				msVertices[cid + 6] = msVertexData(vec4(cpos[0], 0, 1), vColor);
				msVertices[cid + 7] = msVertexData(vec4(mid[1], 0, 1), vColor);
				msVertices[cid + 8] = msVertexData(vec4(cpos[2], 0, 1), vColor);

				msVertices[cid + 9] = msVertexData(vec4(cpos[0], 0, 1), vColor);
				msVertices[cid + 10] = msVertexData(vec4(mid[0], 0, 1), vColor);
				msVertices[cid + 11] = msVertexData(vec4(mid[1], 0, 1), vColor);
			}
			else {
				msVertices[cid] = msVertexData(vec4(cpos[0], 0, 1), vColor);
				msVertices[cid + 1] = msVertexData(vec4(mid[0], 0, 1), vColor);
				msVertices[cid + 2] = msVertexData(vec4(mid[3], 0, 1), vColor);
			
				msVertices[cid + 3] = msVertexData(vec4(cpos[2], 0, 1), vColor);
				msVertices[cid + 4] = msVertexData(vec4(mid[2], 0, 1), vColor);
				msVertices[cid + 5] = msVertexData(vec4(mid[1], 0, 1), vColor);
			}
			break;
		case 10:
			if (avg > minval) { //liquid is in centre of cell
				msVertices[cid] = msVertexData(vec4(cpos[3], 0, 1), vColor);
				msVertices[cid + 1] = msVertexData(vec4(mid[3], 0, 1), vColor);
				msVertices[cid + 2] = msVertexData(vec4(mid[0], 0, 1), vColor);
			
				msVertices[cid + 3] = msVertexData(vec4(cpos[3], 0, 1), vColor);
				msVertices[cid + 4] = msVertexData(vec4(mid[0], 0, 1), vColor);
				msVertices[cid + 5] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			
				msVertices[cid + 6] = msVertexData(vec4(cpos[3], 0, 1), vColor);
				msVertices[cid + 7] = msVertexData(vec4(cpos[1], 0, 1), vColor);
				msVertices[cid + 8] = msVertexData(vec4(mid[1], 0, 1), vColor);

				msVertices[cid + 9] = msVertexData(vec4(cpos[3], 0, 1), vColor);
				msVertices[cid + 10] = msVertexData(vec4(mid[1], 0, 1), vColor);
				msVertices[cid + 11] = msVertexData(vec4(mid[2], 0, 1), vColor);
			}
			else {
				msVertices[cid] = msVertexData(vec4(cpos[3], 0, 1), vColor);
				msVertices[cid + 1] = msVertexData(vec4(mid[3], 0, 1), vColor);
				msVertices[cid + 2] = msVertexData(vec4(mid[2], 0, 1), vColor);
			
				msVertices[cid + 3] = msVertexData(vec4(cpos[1], 0, 1), vColor);
				msVertices[cid + 4] = msVertexData(vec4(mid[1], 0, 1), vColor);
				msVertices[cid + 5] = msVertexData(vec4(mid[0], 0, 1), vColor);
			}
			break;

		//full case
		case 15:
			msVertices[cid] = msVertexData(vec4(cpos[0], 0, 1), vColor);
			msVertices[cid + 1] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 2] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			
			msVertices[cid + 3] = msVertexData(vec4(cpos[1], 0, 1), vColor);
			msVertices[cid + 4] = msVertexData(vec4(cpos[2], 0, 1), vColor);
			msVertices[cid + 5] = msVertexData(vec4(cpos[3], 0, 1), vColor);
			break;
	}
}